<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"daxiongai.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="NDT Matching 算法学习问题背景  近来从事毫米波雷达的定位与建图工作，想拓展下工作思路，研究autoware公司的激光点云定位与建图。期间正好发现autoware的激光点云配准算法是NDT(Normal-Distributions Transform)，相比ICP算法，它能更快速高效地确定两个大型点云的刚性变换。这里分别介绍下2003年经典的2D NDT算法，以及autoware日本团">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://daxiongai.github.io/2020/08/11/NDT%20Matching%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NDT Matching 算法学习问题背景  近来从事毫米波雷达的定位与建图工作，想拓展下工作思路，研究autoware公司的激光点云定位与建图。期间正好发现autoware的激光点云配准算法是NDT(Normal-Distributions Transform)，相比ICP算法，它能更快速高效地确定两个大型点云的刚性变换。这里分别介绍下2003年经典的2D NDT算法，以及autoware日本团">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135515-edb73bc3-1ea8-444b-92fa-bd2e171069d5.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&originHeight=59&originWidth=96&size=0&status=done&style=none&width=96">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135607-29ced738-05f9-49cd-bca2-bec92edbe81b.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=217&size=0&status=done&style=none&width=217">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135564-e5211655-82f3-42ca-bd41-36600464a645.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&originHeight=179&originWidth=554&size=0&status=done&style=none&width=635">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132138188-c18f365a-e244-4fb2-adfa-a2f84afd9052.gif#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=59&size=0&status=done&style=none&width=59">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135597-4aa0b771-d0a0-4149-a342-4feb9374af6e.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=281&size=0&status=done&style=none&width=281">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135687-5d81debd-7714-42b5-ac14-62c5bab11c20.png#align=left&display=inline&height=292&margin=%5Bobject%20Object%5D&originHeight=292&originWidth=675&size=0&status=done&style=none&width=675">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135611-a21d23ea-5306-4308-9075-a87c5e6f0a59.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=319&size=0&status=done&style=none&width=319">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132144159-ebda4a1e-3466-426d-990a-5f49ce4fe766.gif#align=left&display=inline&height=23&margin=%5Bobject%20Object%5D&originHeight=23&originWidth=55&size=0&status=done&style=none&width=55">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132141655-fa8ebc70-59de-426c-9497-4589baf6cd32.gif#align=left&display=inline&height=16&margin=%5Bobject%20Object%5D&originHeight=16&originWidth=11&size=0&status=done&style=none&width=11">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135568-9912f9c1-f3d0-4536-93f7-ca30a026fe6e.png#align=left&display=inline&height=73&margin=%5Bobject%20Object%5D&originHeight=73&originWidth=370&size=0&status=done&style=none&width=370">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132142670-837c0117-0ce8-45f1-a0dc-ed18474ef9bf.gif#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=158&size=0&status=done&style=none&width=158">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135575-f6e2374e-0b85-4c39-bf97-f8f6d2d5f4fd.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&originHeight=54&originWidth=299&size=0&status=done&style=none&width=299">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132138061-9c471f8c-711d-4615-b005-d9b29e029317.gif#align=left&display=inline&height=12&margin=%5Bobject%20Object%5D&originHeight=12&originWidth=9&size=0&status=done&style=none&width=9">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132139238-4a7b606e-9069-4ed6-a2b7-0906a722b62a.gif#align=left&display=inline&height=12&margin=%5Bobject%20Object%5D&originHeight=12&originWidth=9&size=0&status=done&style=none&width=9">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135572-2104c16e-fcd3-4ecc-96f9-127d4dcd84ec.png#align=left&display=inline&height=30&margin=%5Bobject%20Object%5D&originHeight=30&originWidth=244&size=0&status=done&style=none&width=244">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132139435-5ced877f-e58a-42a9-932e-689c7d57aa2a.gif#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=24&size=0&status=done&style=none&width=24">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135599-fb598d0a-4941-47a1-bb09-e6bd98a423d6.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&originHeight=62&originWidth=134&size=0&status=done&style=none&width=134">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135596-c7c3e7e3-b1aa-4692-9886-78ddd5440787.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=278&size=0&status=done&style=none&width=278">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135618-7562c7fb-1102-427f-8fa9-862d3b3f5e0e.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&originHeight=66&originWidth=304&size=0&status=done&style=none&width=304">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135594-56254d5d-88a0-47a3-b997-09f82e5e5283.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=554&size=0&status=done&style=none&width=554">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135555-2f8f9240-9049-4352-a05c-5d42815ead45.png#align=left&display=inline&height=29&margin=%5Bobject%20Object%5D&originHeight=29&originWidth=292&size=0&status=done&style=none&width=292">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135568-72972ac2-4a63-4544-b043-3b55a8047c7c.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=216&size=0&status=done&style=none&width=216">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135595-91cc5504-f3ba-4ba9-b4cb-503411b4ec88.png#align=left&display=inline&height=209&margin=%5Bobject%20Object%5D&originHeight=209&originWidth=554&size=0&status=done&style=none&width=554">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135585-304a4240-ca8f-4329-bd37-abee54f81069.png#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=96&size=0&status=done&style=none&width=96">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135590-42e37afc-ac37-40c4-9df5-e00faf11246c.png#align=left&display=inline&height=63&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=344&size=0&status=done&style=none&width=344">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135623-cede11d3-e0d4-4a84-9333-4f80f6cae19e.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=517&size=0&status=done&style=none&width=517">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135620-9f0bfc29-5273-4c53-b790-fbd987ed79da.png#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&originHeight=232&originWidth=454&size=0&status=done&style=none&width=454">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135622-454f024f-743b-4b38-94ea-5f301fb44f4b.png#align=left&display=inline&height=661&margin=%5Bobject%20Object%5D&originHeight=933&originWidth=1694&size=0&status=done&style=none&width=1200">
<meta property="article:published_time" content="2020-08-11T07:58:25.909Z">
<meta property="article:modified_time" content="2020-08-11T07:58:25.921Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135515-edb73bc3-1ea8-444b-92fa-bd2e171069d5.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&originHeight=59&originWidth=96&size=0&status=done&style=none&width=96">

<link rel="canonical" href="http://daxiongai.github.io/2020/08/11/NDT%20Matching%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://daxiongai.github.io/2020/08/11/NDT%20Matching%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-11 15:58:25" itemprop="dateCreated datePublished" datetime="2020-08-11T15:58:25+08:00">2020-08-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="NDT-Matching-算法学习"><a href="#NDT-Matching-算法学习" class="headerlink" title="NDT Matching 算法学习"></a>NDT Matching 算法学习</h1><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h1><p>  近来从事毫米波雷达的定位与建图工作，想拓展下工作思路，研究autoware公司的激光点云定位与建图。期间正好发现autoware的激光点云配准算法是NDT(Normal-Distributions Transform)，相比ICP算法，它能更快速高效地确定两个大型点云的刚性变换。这里分别介绍下2003年经典的2D NDT算法，以及autoware日本团队在2006年提出的3D NDT算法。<br>“The Normal Distributions Transform: A New Approach to Laser Scan Matching”<br>“A 3-D Scan Matching using Improved 3-D Normal Distributions Transform for Mobile Robotic Mapping”
 </p>
<h1 id="二维ND"><a href="#二维ND" class="headerlink" title="二维ND"></a>二维ND</h1><h2 id="2D-NDT数学描述"><a href="#2D-NDT数学描述" class="headerlink" title="2D NDT数学描述"></a>2D NDT数学描述</h2><p>  假设小车安装了只有一线的2D激光雷达，只能表达一个平面内是否有障碍物。把小车周围的区域划分成大小相同的单元格，我们可以用NDT(Normal Distribution Transform)对扫描的2D点云分布进行建模，用高斯分布表达每个单元格内2D点的聚集情况。若每个单元格包含3个以上的2D点，则计算该单元格内所有点Xi=1,…,n的坐标均值及方差。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135515-edb73bc3-1ea8-444b-92fa-bd2e171069d5.png#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&originHeight=59&originWidth=96&size=0&status=done&style=none&width=96"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135607-29ced738-05f9-49cd-bca2-bec92edbe81b.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=217&size=0&status=done&style=none&width=217"><br>  不同于于栅格图occupancy grid，NDT分布用连续可微的概率密度描述细分区域网格平面内的2D点。栅格图表达的是单元格内包含障碍物的概率，NDT分布本身表示参考帧中特定网格内2D点的位置分布情况。假设下图为参考帧，左侧时栅格图表达空与不空，中间是识别到的2D激光雷达点云，右图表达每个单元格内二维正态概率分布，每个单元格大小相同，越红的地方概率值越大。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135564-e5211655-82f3-42ca-bd41-36600464a645.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&originHeight=179&originWidth=554&size=0&status=done&style=none&width=635"><br>  我们可以NDT分布计算当前帧新观测到的2D点坐标相对于参考帧单元格的概率（不同单元格有不同的均值和方差，均值区域表示参考帧单元格内2D点最密集的区域）。下式表示当前帧2D点x，属于参考帧中某个单元格的概率<img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132138188-c18f365a-e244-4fb2-adfa-a2f84afd9052.gif#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=59&size=0&status=done&style=none&width=59"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135597-4aa0b771-d0a0-4149-a342-4feb9374af6e.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=281&size=0&status=done&style=none&width=281"></p>
<h2 id="如何划分网格并避免离散化的影响"><a href="#如何划分网格并避免离散化的影响" class="headerlink" title="如何划分网格并避免离散化的影响"></a>如何划分网格并避免离散化的影响</h2><p>  个人认为按照上图那样划分网格，破坏了2D点云结构，比如属于同一个物体的点云，被刻意分开到不同单元格计算了。这种离散化不利于地图地描述，也不利于后期点云配准。我们分别看看建图和定位时，如何划分网格，计算概率密度。<br>  <strong>建图时</strong>，给定参考帧laser scan的2D点云，根据点云坐标上下界以及cell size确定外侧bounding box下图蓝色边框所示。对于边框内部采用4个单元格相互重叠的，两两覆盖50%，分别计算每个子网格的点云正态分布。因此这种划分包含了4种均值和方差。下右图只是示意，实际上蓝色框图内将有多个单元格，可以认为蓝色框图内大部分的2D点会同时落入四种单元格内。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135687-5d81debd-7714-42b5-ac14-62c5bab11c20.png#align=left&display=inline&height=292&margin=%5Bobject%20Object%5D&originHeight=292&originWidth=675&size=0&status=done&style=none&width=675"><br>  <strong>定位时</strong>，计算前后两帧pose关系，给定当前帧laser scan的2D点云，根据T(待优化的参数)转换后的坐标查找落入哪个单元格内，同样当前帧每个2d点将对应四种分布。累计所有2d点对应的四种概率密度之和，通过选择合理的T，使得概率密度之和最大。</p>
<h2 id="如何计算两片点云相对位姿"><a href="#如何计算两片点云相对位姿" class="headerlink" title="如何计算两片点云相对位姿"></a>如何计算两片点云相对位姿</h2><p>  假设用T表达2D空间内，两个时刻机器人的位姿变换关系。下面公式表达了当前帧的2D点云在上一帧坐标系的坐标<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135611-a21d23ea-5306-4308-9075-a87c5e6f0a59.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=319&size=0&status=done&style=none&width=319"><br><img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132144159-ebda4a1e-3466-426d-990a-5f49ce4fe766.gif#align=left&display=inline&height=23&margin=%5Bobject%20Object%5D&originHeight=23&originWidth=55&size=0&status=done&style=none&width=55">表示位移，<img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132141655-fa8ebc70-59de-426c-9497-4589baf6cd32.gif#align=left&display=inline&height=16&margin=%5Bobject%20Object%5D&originHeight=16&originWidth=11&size=0&status=done&style=none&width=11">表示旋转角度。Scan alignment目的就是通过前后两帧的laser scan复原位移和角度。假设给定两帧激光点云的测量，具体步骤如下：<br>(1)用第一帧laser scan，按照上述过程计算初始NDT分布<br>(2)初始化位姿变换参数T，全零或者用odometry初始化<br>(3)根据位姿变换参数T，将第二帧的laser scan点云转换到第一帧坐标系下<br>(4)为第二帧的每个2D点分配网格，计算点云对应的四种概率分布<br>(5)累计点云的概率分布，计算总体得分<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135568-9912f9c1-f3d0-4536-93f7-ca30a026fe6e.png#align=left&display=inline&height=73&margin=%5Bobject%20Object%5D&originHeight=73&originWidth=370&size=0&status=done&style=none&width=370"><br>p是第二帧点云，x’是第二帧点云p经T投影在第一帧的坐标，q和sigma是x’所属第一帧的网格概率分布。<br>(6)用牛顿法优化参数T (任意非线性优化算法均可)，使得score得分最高 [对于牛顿法，迭代步长的要点是求score函数的一阶和二阶偏导数，此处不扩展]<br>(7)回到步骤(3)，重复上述步骤，优化算法收敛</p>
<h2 id="2D-NDT在SLAM中的应用"><a href="#2D-NDT在SLAM中的应用" class="headerlink" title="2D NDT在SLAM中的应用"></a>2D NDT在SLAM中的应用</h2><p>以下内容是我基于2003年那篇论文的理解，给出大致思路。<br>建图：<br>  Slam地图由图结构表达，每个顶点表示当前关键帧机器人绝对位姿，顶点之间的边表示前后两帧关键帧之间2D点云经过NDT配准推算出来的relative pose（可以看作是odometry，如果有IMU或轮速传感器，就不用NDT推算前后航迹了）。地图元素就是2D 点云的正态分布(均值看作2D点云的位置，方差可看作2D点云覆盖范围)，并且这些分布根据每个顶点的全局坐标，也转换到全局坐标下了。<br>  每新增一个顶点，或者叫新增关键帧，理论上所有其他顶点都要参与全局优化。关于全局目标函数，每个顶点的全局位姿可以得到两个顶点之间相对位姿，而两个顶点对应的laser scan根据NDT匹配也能推算出相对位姿。由于全局位姿未知，我们希望通过估算两种相对位姿的差(这样能反推全局位姿)，使得整体score得分最小，所以优化的目标函数是关于位姿之差的二次函数（关于score函数在NDT配准的相对位姿处二阶泰勒展开，一次项在左侧，<img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132142670-837c0117-0ce8-45f1-a0dc-ed18474ef9bf.gif#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=158&size=0&status=done&style=none&width=158">)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135575-f6e2374e-0b85-4c39-bf97-f8f6d2d5f4fd.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&originHeight=54&originWidth=299&size=0&status=done&style=none&width=299"><br>  另外随着关键帧增加，全局优化的顶点越来越多，无法实时计算。因此每次新增顶点，只优化三条连接边以内的子图。<br>定位：<br>  假设k-n时刻的测量是关键帧，给定k-n与k时刻的里程计估计<img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132138061-9c471f8c-711d-4615-b005-d9b29e029317.gif#align=left&display=inline&height=12&margin=%5Bobject%20Object%5D&originHeight=12&originWidth=9&size=0&status=done&style=none&width=9">，将k时刻测量到的2D点云根据 <img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132139238-4a7b606e-9069-4ed6-a2b7-0906a722b62a.gif#align=left&display=inline&height=12&margin=%5Bobject%20Object%5D&originHeight=12&originWidth=9&size=0&status=done&style=none&width=9">投影到k-n时刻。通过计算k-n时刻与k时刻的NDT score，通过优化得到的位姿作为k时刻位姿。如果k时刻的测量距离k-n时刻的关键帧较远，则把最近一次NDT匹配成功的测量作为新的关键帧。<br>下面时matlab 工具箱内关于2D NDT Matching的代码<br>preNDT函数将激光数据点划分到指定大小的网格中：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="params">[xgridcoords, ygridcoords]</span> = <span class="title">preNDT</span><span class="params">(laserScan, cellSize)</span></span></span><br><span class="line"><span class="number">2.</span> <span class="comment">%preNDT Calculate cell coordinates based on laser scan</span></span><br><span class="line"><span class="number">3.</span> <span class="comment">%   [XGRIDCOORDS, YGRIDCOORDS] = preNDT(LASERSCAN, CELLSIZE) calculated the x</span></span><br><span class="line"><span class="number">4.</span> <span class="comment">%   (XGRIDCOORDS) and y (YGRIDCOORDS) coordinates of the cell center points that are</span></span><br><span class="line"><span class="number">5.</span> <span class="comment">%   used to discretize the given laser scan.</span></span><br><span class="line"><span class="number">6.</span> <span class="comment">%</span></span><br><span class="line"><span class="number">7.</span> <span class="comment">%   Inputs:</span></span><br><span class="line"><span class="number">8.</span> <span class="comment">%      LASERSCAN - N-by-2 array of 2D Cartesian points</span></span><br><span class="line"><span class="number">9.</span> <span class="comment">%      CELLSIZE - Defines the side length of each cell used to build NDT.</span></span><br><span class="line"><span class="number">10.</span> <span class="comment">%         Each cell is square</span></span><br><span class="line"><span class="number">11.</span> <span class="comment">%</span></span><br><span class="line"><span class="number">12.</span> <span class="comment">%   Outputs:</span></span><br><span class="line"><span class="number">13.</span> <span class="comment">%      XGRIDCOORDS - 4-by-K, the discretized x coordinates using cells with size</span></span><br><span class="line"><span class="number">14.</span> <span class="comment">%         equal to CELLSIZE.</span></span><br><span class="line"><span class="number">15.</span> <span class="comment">%      YGRIDCOORDS: 4-by-K, the discretized y coordinates using cells with size</span></span><br><span class="line"><span class="number">16.</span> <span class="comment">%         equal to CELLSIZE.</span></span><br><span class="line"><span class="number">17.</span> </span><br><span class="line"><span class="number">18.</span> xmin = <span class="built_in">min</span>(laserScan(:,<span class="number">1</span>));</span><br><span class="line"><span class="number">19.</span> ymin = <span class="built_in">min</span>(laserScan(:,<span class="number">2</span>));</span><br><span class="line"><span class="number">20.</span> xmax = <span class="built_in">max</span>(laserScan(:,<span class="number">1</span>));</span><br><span class="line"><span class="number">21.</span> ymax = <span class="built_in">max</span>(laserScan(:,<span class="number">2</span>));</span><br><span class="line"><span class="number">22.</span> </span><br><span class="line"><span class="number">23.</span> halfCellSize = cellSize/<span class="number">2</span>;</span><br><span class="line"><span class="number">24.</span> </span><br><span class="line"><span class="number">25.</span> lowerBoundX = <span class="built_in">floor</span>(xmin/cellSize)*cellSize-cellSize;</span><br><span class="line"><span class="number">26.</span> upperBoundX = <span class="built_in">ceil</span>(xmax/cellSize)*cellSize+cellSize;</span><br><span class="line"><span class="number">27.</span> lowerBoundY = <span class="built_in">floor</span>(ymin/cellSize)*cellSize-cellSize;</span><br><span class="line"><span class="number">28.</span> upperBoundY = <span class="built_in">ceil</span>(ymax/cellSize)*cellSize+cellSize;</span><br><span class="line"><span class="number">29.</span> </span><br><span class="line"><span class="number">30.</span> <span class="comment">% To minimize the effects of discretization,use four overlapping</span></span><br><span class="line"><span class="number">31.</span> <span class="comment">% grids. That is, one grid with side length cellSize of a single cell is placed</span></span><br><span class="line"><span class="number">32.</span> <span class="comment">% first, then a second one, shifted by cellSize/2 horizontally, a third</span></span><br><span class="line"><span class="number">33.</span> <span class="comment">% one, shifted by cellSize/2 vertically and a fourth one, shifted by</span></span><br><span class="line"><span class="number">34.</span> <span class="comment">% cellSize/2 horizontally and vertically.</span></span><br><span class="line"><span class="number">35.</span> </span><br><span class="line"><span class="number">36.</span> xgridcoords = [  lowerBoundX:cellSize:upperBoundX;...                       <span class="comment">% Grid of cells in position 1</span></span><br><span class="line"><span class="number">37.</span>             lowerBoundX+halfCellSize:cellSize:upperBoundX+halfCellSize;...  <span class="comment">% Grid of cells in position 2 (X Right, Y Same)</span></span><br><span class="line"><span class="number">38.</span>             lowerBoundX:cellSize:upperBoundX; ...                           <span class="comment">% Grid of cells in position 3 (X Same, Y Up)    </span></span><br><span class="line"><span class="number">39.</span>             lowerBoundX+halfCellSize:cellSize:upperBoundX+halfCellSize];    <span class="comment">% Grid of cells in position 4 (X Right, Y Up)</span></span><br><span class="line"><span class="number">40.</span> </span><br><span class="line"><span class="number">41.</span> ygridcoords = [  lowerBoundY:cellSize:upperBoundY;...                         <span class="comment">% Grid of cells in position 1</span></span><br><span class="line"><span class="number">42.</span>             lowerBoundY:cellSize:upperBoundY;...                            <span class="comment">% Grid of cells in position 2 (X Right, Y Same)</span></span><br><span class="line"><span class="number">43.</span>             lowerBoundY+halfCellSize:cellSize:upperBoundY+halfCellSize;...  <span class="comment">% Grid of cells in position 3 (X Same, Y Up)    </span></span><br><span class="line"><span class="number">44.</span>             lowerBoundY+halfCellSize:cellSize:upperBoundY+halfCellSize];    <span class="comment">% Grid of cells in position 4 (X Right, Y Up)</span></span><br><span class="line"><span class="number">45.</span> </span><br><span class="line"><span class="number">46.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>　buildNDT函数根据划分好的网格，来计算每一个小格子中的二维正态分布参数（均值、协方差矩阵以及协方差矩阵的逆）：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="params">[xgridcoords, ygridcoords, meanq, covar, covarInv]</span> = <span class="title">buildNDT</span><span class="params">(laserScan, cellSize)</span></span></span><br><span class="line"><span class="number">2.</span> <span class="comment">%buildNDT Build Normal Distributions Transform from laser scan</span></span><br><span class="line"><span class="number">3.</span> <span class="comment">%   [XGRIDCOORDS, YGRIDCOORDS, MEANQ, COVAR, COVARINV] = buildNDT(LASERSCAN, CELLSIZE)</span></span><br><span class="line"><span class="number">4.</span> <span class="comment">%   discretizes the laser scan points into cells and approximates each cell</span></span><br><span class="line"><span class="number">5.</span> <span class="comment">%   with a Normal distribution.</span></span><br><span class="line"><span class="number">6.</span> <span class="comment">%</span></span><br><span class="line"><span class="number">7.</span> <span class="comment">%   Inputs:</span></span><br><span class="line"><span class="number">8.</span> <span class="comment">%      LASERSCAN - N-by-2 array of 2D Cartesian points</span></span><br><span class="line"><span class="number">9.</span> <span class="comment">%      CELLSIZE - Defines the side length of each cell used to build NDT.</span></span><br><span class="line"><span class="number">10.</span> <span class="comment">%         Each cell is a square area used to discretize the space.</span></span><br><span class="line"><span class="number">11.</span> <span class="comment">%</span></span><br><span class="line"><span class="number">12.</span> <span class="comment">%   Outputs:</span></span><br><span class="line"><span class="number">13.</span> <span class="comment">%      XGRIDCOORDS - 4-by-K, the discretized x coordinates of the grid of cells, </span></span><br><span class="line"><span class="number">14.</span> <span class="comment">%         with each cell having a side length equal to CELLSIZE.</span></span><br><span class="line"><span class="number">15.</span> <span class="comment">%         Note that K increases when CELLSIZE decreases.</span></span><br><span class="line"><span class="number">16.</span> <span class="comment">%         The second row shifts the first row by CELLSIZE/2 to</span></span><br><span class="line"><span class="number">17.</span> <span class="comment">%         the right. The third row shifts the first row by CELLSIZE/2 to the</span></span><br><span class="line"><span class="number">18.</span> <span class="comment">%         top. The fourth row shifts the first row by CELLSIZE/2 to the right and</span></span><br><span class="line"><span class="number">19.</span> <span class="comment">%         top. The same row semantics apply to YGRIDCOORDS, MEANQ, COVAR, and COVARINV.</span></span><br><span class="line"><span class="number">20.</span> <span class="comment">%      YGRIDCOORDS: 4-by-K, the discretized y coordinates of the grid of cells, </span></span><br><span class="line"><span class="number">21.</span> <span class="comment">%         with each cell having a side length equal to CELLSIZE.</span></span><br><span class="line"><span class="number">22.</span> <span class="comment">%      MEANQ: 4-by-K-by-K-by-2, the mean of the points in cells described by</span></span><br><span class="line"><span class="number">23.</span> <span class="comment">%         XGRIDCOORDS and YGRIDCOORDS.</span></span><br><span class="line"><span class="number">24.</span> <span class="comment">%      COVAR: 4-by-K-by-K-by-2-by-2, the covariance of the points in cells</span></span><br><span class="line"><span class="number">25.</span> <span class="comment">%      COVARINV: 4-by-K-by-K-by-2-by-2, the inverse of the covariance of </span></span><br><span class="line"><span class="number">26.</span> <span class="comment">%         the points in cells.</span></span><br><span class="line"><span class="number">27.</span> <span class="comment">%</span></span><br><span class="line"><span class="number">28.</span> <span class="comment">%   [XGRIDCOORDS, YGRIDCOORDS, MEANQ, COVAR, COVARINV] describe the NDT statistics.</span></span><br><span class="line"><span class="number">29.</span> </span><br><span class="line"><span class="number">30.</span> <span class="comment">%   Copyright 2016 The MathWorks, Inc.</span></span><br><span class="line"><span class="number">31.</span> </span><br><span class="line"><span class="number">32.</span> </span><br><span class="line"><span class="number">33.</span> <span class="comment">% When the scan contains ONLY NaN values (no valid range readings), </span></span><br><span class="line"><span class="number">34.</span> <span class="comment">% the input laserScan is empty. Explicitly</span></span><br><span class="line"><span class="number">35.</span> <span class="comment">% initialize empty variables to support code generation.</span></span><br><span class="line"><span class="number">36.</span> <span class="keyword">if</span> <span class="built_in">isempty</span>(laserScan)</span><br><span class="line"><span class="number">37.</span>     xgridcoords      = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"><span class="number">38.</span>     ygridcoords      = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"><span class="number">39.</span>     meanq       = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">40.</span>     covar       = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">41.</span>     covarInv    = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">42.</span>     <span class="keyword">return</span>;</span><br><span class="line"><span class="number">43.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">44.</span> </span><br><span class="line"><span class="number">45.</span> <span class="comment">% Discretize the laser scan into cells</span></span><br><span class="line"><span class="number">46.</span> [xgridcoords, ygridcoords] = preNDT(laserScan, cellSize);</span><br><span class="line"><span class="number">47.</span> </span><br><span class="line"><span class="number">48.</span> xNumCells = <span class="built_in">size</span>(xgridcoords,<span class="number">2</span>);</span><br><span class="line"><span class="number">49.</span> yNumCells = <span class="built_in">size</span>(ygridcoords,<span class="number">2</span>);</span><br><span class="line"><span class="number">50.</span> </span><br><span class="line"><span class="number">51.</span> <span class="comment">% Preallocate outputs</span></span><br><span class="line"><span class="number">52.</span> meanq = <span class="built_in">zeros</span>(<span class="number">4</span>,xNumCells,yNumCells,<span class="number">2</span>);</span><br><span class="line"><span class="number">53.</span> covar = <span class="built_in">zeros</span>(<span class="number">4</span>,xNumCells,yNumCells,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">54.</span> covarInv = <span class="built_in">zeros</span>(<span class="number">4</span>,xNumCells,yNumCells,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">55.</span> </span><br><span class="line"><span class="number">56.</span> <span class="comment">% For each cell, compute the normal distribution that can approximately</span></span><br><span class="line"><span class="number">57.</span> <span class="comment">% describe the distribution of the points within the cell.</span></span><br><span class="line"><span class="number">58.</span> <span class="keyword">for</span> cellShiftMode = <span class="number">1</span>:<span class="number">4</span></span><br><span class="line"><span class="number">59.</span> <span class="comment">% Find the points in the cell</span></span><br><span class="line"><span class="number">60.</span> <span class="comment">% First find all points in the xgridcoords and ygridcoords separately and then combine the result.</span></span><br><span class="line"><span class="number">61.</span>     <span class="comment">% indx的值表示laserScan的x坐标分别在xgridcoords划分的哪个范围中(例如1就表示落在第1个区间;若不在范围中,则返回0)</span></span><br><span class="line"><span class="number">62.</span>     [~, indx] = histc(laserScan(:,<span class="number">1</span>), xgridcoords(cellShiftMode, :)); </span><br><span class="line"><span class="number">63.</span>     [~, indy] = histc(laserScan(:,<span class="number">2</span>), ygridcoords(cellShiftMode, :));</span><br><span class="line"><span class="number">64.</span>     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:xNumCells</span><br><span class="line"><span class="number">65.</span>         xflags = (indx == <span class="built_in">i</span>); <span class="comment">% xflags is a logical vector</span></span><br><span class="line"><span class="number">66.</span>         <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:yNumCells</span><br><span class="line"><span class="number">67.</span>             yflags = (indy == <span class="built_in">j</span>);</span><br><span class="line"><span class="number">68.</span>             xyflags = logical(xflags .* yflags);</span><br><span class="line"><span class="number">69.</span>             xymemberInCell = laserScan(xyflags,:);  <span class="comment">% laser points in the cell</span></span><br><span class="line"><span class="number">70.</span> </span><br><span class="line"><span class="number">71.</span> <span class="comment">% If there are more than 3 points in the cell, compute the</span></span><br><span class="line"><span class="number">72.</span> <span class="comment">% statistics. Otherwise, all statistics remain zero.</span></span><br><span class="line"><span class="number">73.</span> <span class="comment">% See reference [1], section III.</span></span><br><span class="line"><span class="number">74.</span> <span class="keyword">if</span> <span class="built_in">size</span>(xymemberInCell, <span class="number">1</span>) &gt; <span class="number">3</span></span><br><span class="line"><span class="number">75.</span> </span><br><span class="line"><span class="number">76.</span> <span class="comment">% Compute mean and covariance</span></span><br><span class="line"><span class="number">77.</span>                 xymean = <span class="built_in">mean</span>(xymemberInCell);</span><br><span class="line"><span class="number">78.</span>                 xyCov = cov(xymemberInCell, <span class="number">1</span>);</span><br><span class="line"><span class="number">79.</span> </span><br><span class="line"><span class="number">80.</span> <span class="comment">% Prevent covariance matrix from going singular (and not be</span></span><br><span class="line"><span class="number">81.</span> <span class="comment">% invertible). See reference [1], section III.</span></span><br><span class="line"><span class="number">82.</span>                 [U,S,V] = svd(xyCov);</span><br><span class="line"><span class="number">83.</span> <span class="keyword">if</span> S(<span class="number">2</span>,<span class="number">2</span>) &lt; <span class="number">0.001</span> * S(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">84.</span>                     S(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">0.001</span> * S(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">85.</span>                     xyCov = U*S*V&#x27;;</span><br><span class="line"><span class="number">86.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">87.</span> </span><br><span class="line"><span class="number">88.</span>                 [~, posDef] = chol(xyCov);                </span><br><span class="line"><span class="number">89.</span> <span class="keyword">if</span> posDef ~= <span class="number">0</span></span><br><span class="line"><span class="number">90.</span> <span class="comment">% If the covariance matrix is not positive definite,</span></span><br><span class="line"><span class="number">91.</span> <span class="comment">% disregard the contributions of this cell.</span></span><br><span class="line"><span class="number">92.</span>                     <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">93.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">94.</span> </span><br><span class="line"><span class="number">95.</span> <span class="comment">% Store statistics</span></span><br><span class="line"><span class="number">96.</span>                 meanq(cellShiftMode,<span class="built_in">i</span>,<span class="built_in">j</span>,:) = xymean;</span><br><span class="line"><span class="number">97.</span>                 covar(cellShiftMode,<span class="built_in">i</span>,<span class="built_in">j</span>,:,:) = xyCov;</span><br><span class="line"><span class="number">98.</span>                 covarInv(cellShiftMode,<span class="built_in">i</span>,<span class="built_in">j</span>,:,:) = inv(xyCov);                </span><br><span class="line"><span class="number">99.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">100.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">101.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">102.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">103.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>objectiveNDT函数根据变换参数计算目标函数值及其梯度和Hessian矩阵，objectiveNDT的输出参数将作为目标函数信息传入优化函数中：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="params">[score, gradient, hessian]</span> = <span class="title">objectiveNDT</span><span class="params">(laserScan, laserTrans, xgridcoords, ygridcoords, meanq, covar, covarInv)</span></span></span><br><span class="line"><span class="number">2.</span> <span class="comment">%objectiveNDT Calculate objective function for NDT-based scan matching</span></span><br><span class="line"><span class="number">3.</span> <span class="comment">%   [SCORE, GRADIENT, HESSIAN] = objectiveNDT(LASERSCAN, LASERTRANS, XGRIDCOORDS,</span></span><br><span class="line"><span class="number">4.</span> <span class="comment">%   YGRIDCOORDS, MEANQ, COVAR, COVARINV) calculates the NDT objective function by</span></span><br><span class="line"><span class="number">5.</span> <span class="comment">%   matching the LASERSCAN transformed by LASERTRANS to the NDT described</span></span><br><span class="line"><span class="number">6.</span> <span class="comment">%   by XGRIDCOORDS, YGRIDCOORDS, MEANQ, COVAR, and COVARINV.</span></span><br><span class="line"><span class="number">7.</span> <span class="comment">%   The NDT score is returned in SCORE, along with the optionally</span></span><br><span class="line"><span class="number">8.</span> <span class="comment">%   calculated score GRADIENT, and score HESSIAN.</span></span><br><span class="line"><span class="number">9.</span> </span><br><span class="line"><span class="number">10.</span> <span class="comment">%   Copyright 2016 The MathWorks, Inc.</span></span><br><span class="line"><span class="number">11.</span> </span><br><span class="line"><span class="number">12.</span> <span class="comment">% Create rotation matrix</span></span><br><span class="line"><span class="number">13.</span> theta = laserTrans(<span class="number">3</span>);</span><br><span class="line"><span class="number">14.</span> sintheta = <span class="built_in">sin</span>(theta);</span><br><span class="line"><span class="number">15.</span> costheta = <span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="number">16.</span> </span><br><span class="line"><span class="number">17.</span> rotm = [costheta -sintheta;</span><br><span class="line"><span class="number">18.</span>         sintheta costheta];</span><br><span class="line"><span class="number">19.</span> </span><br><span class="line"><span class="number">20.</span> <span class="comment">% Create 2D homogeneous transform</span></span><br><span class="line"><span class="number">21.</span> trvec = [laserTrans(<span class="number">1</span>); laserTrans(<span class="number">2</span>)];</span><br><span class="line"><span class="number">22.</span> tform = [rotm, trvec</span><br><span class="line"><span class="number">23.</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="number">24.</span> </span><br><span class="line"><span class="number">25.</span> <span class="comment">% Create homogeneous points for laser scan</span></span><br><span class="line"><span class="number">26.</span> hom = [laserScan, <span class="built_in">ones</span>(<span class="built_in">size</span>(laserScan,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"><span class="number">27.</span> </span><br><span class="line"><span class="number">28.</span> <span class="comment">% Apply homogeneous transform</span></span><br><span class="line"><span class="number">29.</span> trPts = hom * tform&#x27;;  <span class="comment">% Eqn (2)</span></span><br><span class="line"><span class="number">30.</span> </span><br><span class="line"><span class="number">31.</span> <span class="comment">% Convert back to Cartesian points</span></span><br><span class="line"><span class="number">32.</span> laserTransformed = trPts(:,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line"><span class="number">33.</span> </span><br><span class="line"><span class="number">34.</span> hessian = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="number">35.</span> gradient = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">36.</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="number">37.</span> </span><br><span class="line"><span class="number">38.</span> <span class="comment">% Compute the score, gradient and Hessian according to the NDT paper</span></span><br><span class="line"><span class="number">39.</span> <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(laserTransformed,<span class="number">1</span>) <span class="comment">% 对每一个转换点进行处理</span></span><br><span class="line"><span class="number">40.</span>     xprime = laserTransformed(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">41.</span>     yprime = laserTransformed(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">42.</span> </span><br><span class="line"><span class="number">43.</span>     x = laserScan(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">44.</span>     y = laserScan(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">45.</span> </span><br><span class="line"><span class="number">46.</span> <span class="comment">% Eqn (11)</span></span><br><span class="line"><span class="number">47.</span>     jacobianT = [<span class="number">1</span> <span class="number">0</span> -x*sintheta - y*costheta;</span><br><span class="line"><span class="number">48.</span> <span class="number">1</span>  x*costheta - y*sintheta];</span><br><span class="line"><span class="number">49.</span> </span><br><span class="line"><span class="number">50.</span> <span class="comment">% Eqn (13)</span></span><br><span class="line"><span class="number">51.</span>     qp3p3 = [-x*costheta + y*sintheta;</span><br><span class="line"><span class="number">52.</span>              -x*sintheta - y*costheta];</span><br><span class="line"><span class="number">53.</span> </span><br><span class="line"><span class="number">54.</span>     <span class="keyword">for</span> cellShiftMode = <span class="number">1</span>:<span class="number">4</span></span><br><span class="line"><span class="number">55.</span>         [~,m] = histc(xprime, xgridcoords(cellShiftMode, :)); <span class="comment">% 转换点落在(m,n)格子中</span></span><br><span class="line"><span class="number">56.</span>         [~,n] = histc(yprime, ygridcoords(cellShiftMode, :));</span><br><span class="line"><span class="number">57.</span> </span><br><span class="line"><span class="number">58.</span> <span class="keyword">if</span> m == <span class="number">0</span> || n == <span class="number">0</span></span><br><span class="line"><span class="number">59.</span>             <span class="keyword">continue</span></span><br><span class="line"><span class="number">60.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">61.</span>         meanmn = <span class="built_in">reshape</span>(meanq(cellShiftMode,m,n,:),<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">62.</span>         covarmn = <span class="built_in">reshape</span>(covar(cellShiftMode,m,n,:,:),<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">63.</span>         covarmninv = <span class="built_in">reshape</span>(covarInv(cellShiftMode,m,n,:,:),<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">64.</span> </span><br><span class="line"><span class="number">65.</span> <span class="keyword">if</span> ~any([any(meanmn), any(covarmn)])</span><br><span class="line"><span class="number">66.</span> <span class="comment">% Ignore cells that contained less than 3 points</span></span><br><span class="line"><span class="number">67.</span>             <span class="keyword">continue</span></span><br><span class="line"><span class="number">68.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">69.</span> </span><br><span class="line"><span class="number">70.</span> <span class="comment">% Eqn (3)</span></span><br><span class="line"><span class="number">71.</span>         q = [xprime;yprime] - meanmn;</span><br><span class="line"><span class="number">72.</span> <span class="comment">% As per the paper, this term should represent the probability of</span></span><br><span class="line"><span class="number">73.</span> <span class="comment">% the match of the point with the specific cell</span></span><br><span class="line"><span class="number">74.</span>         gaussianValue = <span class="built_in">exp</span>(-q&#x27;*covarmninv*q/<span class="number">2</span>);</span><br><span class="line"><span class="number">75.</span>         score = score - gaussianValue;</span><br><span class="line"><span class="number">76.</span> </span><br><span class="line"><span class="number">77.</span>         <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line"><span class="number">78.</span> <span class="comment">% Eqn (10)</span></span><br><span class="line"><span class="number">79.</span>             gradient(<span class="built_in">j</span>) = gradient(<span class="built_in">j</span>) + q&#x27;*covarmninv*jacobianT(:,<span class="built_in">j</span>)*gaussianValue;</span><br><span class="line"><span class="number">80.</span> <span class="comment">% Eqn (12)</span></span><br><span class="line"><span class="number">81.</span>             qpj = jacobianT(:,<span class="built_in">j</span>);</span><br><span class="line"><span class="number">82.</span>             <span class="keyword">for</span> k = <span class="built_in">j</span>:<span class="number">3</span>           <span class="comment">% Hessian矩阵为对称矩阵,只需要计算对角线上的部分</span></span><br><span class="line"><span class="number">83.</span>                 qpk = jacobianT(:,k);</span><br><span class="line"><span class="number">84.</span> <span class="keyword">if</span> <span class="built_in">j</span> == <span class="number">3</span> &amp;&amp; k == <span class="number">3</span></span><br><span class="line"><span class="number">85.</span>                     hessian(<span class="built_in">j</span>,k) = hessian(<span class="built_in">j</span>,k) + gaussianValue*(-(q&#x27;*covarmninv*qpj)*(q&#x27;*covarmninv*qpk) +(q&#x27;*covarmninv*qp3p3) + (qpk&#x27;*covarmninv*qpj));</span><br><span class="line"><span class="number">86.</span>                 <span class="keyword">else</span></span><br><span class="line"><span class="number">87.</span>                     hessian(<span class="built_in">j</span>,k) = hessian(<span class="built_in">j</span>,k) + gaussianValue*(-(q&#x27;*covarmninv*qpj)*(q&#x27;*covarmninv*qpk) + (qpk&#x27;*covarmninv*qpj));</span><br><span class="line"><span class="number">88.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">89.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">90.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">91.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">92.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">93.</span> </span><br><span class="line"><span class="number">94.</span> <span class="comment">% 补全Hessian矩阵</span></span><br><span class="line"><span class="number">95.</span> <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line"><span class="number">96.</span>     <span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span></span><br><span class="line"><span class="number">97.</span>         hessian(<span class="built_in">j</span>,k) = hessian(k,<span class="built_in">j</span>);</span><br><span class="line"><span class="number">98.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">99.</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">100.</span> </span><br><span class="line"><span class="number">101.</span> score = double(score);</span><br><span class="line"><span class="number">102.</span> gradient = double(gradient);</span><br><span class="line"><span class="number">103.</span> hessian = double(hessian);</span><br><span class="line"><span class="number">104.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="三维NDT"><a href="#三维NDT" class="headerlink" title="三维NDT"></a>三维NDT</h1><h2 id="三维NDT分布数学描述"><a href="#三维NDT分布数学描述" class="headerlink" title="三维NDT分布数学描述"></a>三维NDT分布数学描述</h2><p>接下来看看NDT如何处理三维激光数据，假设有参考帧3D点集<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135572-2104c16e-fcd3-4ecc-96f9-127d4dcd84ec.png#align=left&display=inline&height=30&margin=%5Bobject%20Object%5D&originHeight=30&originWidth=244&size=0&status=done&style=none&width=244"><br>它们将被分配到称作ND voxel的三维网格中，对于第k个voxel，里面有<img src="https://cdn.nlark.com/yuque/0/2020/gif/2158811/1597132139435-5ced877f-e58a-42a9-932e-689c7d57aa2a.gif#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=24&size=0&status=done&style=none&width=24"> 个3D点。对于该网格的NDT分布的均值和方差：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135599-fb598d0a-4941-47a1-bb09-e6bd98a423d6.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&originHeight=62&originWidth=134&size=0&status=done&style=none&width=134"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135596-c7c3e7e3-b1aa-4692-9886-78ddd5440787.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=278&size=0&status=done&style=none&width=278"><br>那么该网格的概率密度函数为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135618-7562c7fb-1102-427f-8fa9-862d3b3f5e0e.png#align=left&display=inline&height=66&margin=%5Bobject%20Object%5D&originHeight=66&originWidth=304&size=0&status=done&style=none&width=304"><br>  如下图所示，reference点集会被三维网格包围构造多维正态分布。为了克服离散化问题，不同于2D点集，这里每个3D点会被8个三维网格包围。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135594-56254d5d-88a0-47a3-b997-09f82e5e5283.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=554&size=0&status=done&style=none&width=554"></p>
<h2 id="3D-NDT分布更新"><a href="#3D-NDT分布更新" class="headerlink" title="3D NDT分布更新"></a>3D NDT分布更新</h2><p>  随着地图扩张，每次三维网格内新增了参考点，均值和协方差(关于x,y,z)都会重复计算且计算量会逐渐增加。为了减少计算量，对于第k个voxel，其均值p和协方差sigma采用如下方式增量更新，计算复杂度与网格中3D点的个数无关。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135555-2f8f9240-9049-4352-a05c-5d42815ead45.png#align=left&display=inline&height=29&margin=%5Bobject%20Object%5D&originHeight=29&originWidth=292&size=0&status=done&style=none&width=292"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135568-72972ac2-4a63-4544-b043-3b55a8047c7c.png#align=left&display=inline&height=60&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=216&size=0&status=done&style=none&width=216"><br>  下图是3D点云对应网格的NDT可视化<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135595-91cc5504-f3ba-4ba9-b4cb-503411b4ec88.png#align=left&display=inline&height=209&margin=%5Bobject%20Object%5D&originHeight=209&originWidth=554&size=0&status=done&style=none&width=554"></p>
<h2 id="如何进行3D点云NDT配准"><a href="#如何进行3D点云NDT配准" class="headerlink" title="如何进行3D点云NDT配准"></a>如何进行3D点云NDT配准</h2><p>  给定两个3D点集，如何通过NDT分布计算二者的相对位姿呢？先看看三维空间的坐标变换，点集X通过(R,t)变换，R是旋转矩阵，t是平移向量<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135585-304a4240-ca8f-4329-bd37-abee54f81069.png#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=96&size=0&status=done&style=none&width=96"><br>  给定参考帧点云以及当前帧点云，配准问题就变成了(R,t)参数搜索问题。根据参考帧点云构造NDT分布，通过寻找合适的坐标变换参数使得当前帧点云对应的NDT概率密度之和最大。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135590-42e37afc-ac37-40c4-9df5-e00faf11246c.png#align=left&display=inline&height=63&margin=%5Bobject%20Object%5D&originHeight=63&originWidth=344&size=0&status=done&style=none&width=344"><br>这里同样使用牛顿优化法求解参数R和t</p>
<h2 id="NDT三维网格的设计"><a href="#NDT三维网格的设计" class="headerlink" title="NDT三维网格的设计"></a>NDT三维网格的设计</h2><p>如果三维网格voxel大小不当，那么NDT配准时会出问题。如下图所示，<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135623-cede11d3-e0d4-4a84-9333-4f80f6cae19e.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=517&size=0&status=done&style=none&width=517"><br>  图a中黑点为参考帧，白点为当前帧，如果voxel网格尺寸太小，当前帧左上角点云没有对应的参考帧点云，对NDT配准位置修正没有贡献，反而增加了牛顿法收敛时间。另外，如果网格内点云数量过小，无法形成正态分布。<br>  图b中，如果voxel网格尺寸较大，白色点和黑色点本不属于同一物体，虽然收敛速度很快，但是最终匹配结果是错误的。<br>  图c中，如果voxel网格尺寸过大，网格中有两种参考点的分布，单核正态分布(单峰)不足以描述它们，所以当前帧同这种分布配准时，往往也是失败的。</p>
<h2 id="如何改进"><a href="#如何改进" class="headerlink" title="如何改进"></a>如何改进</h2><p>  总之，网格越小，计算量越大，消耗内存大，但是匹配更精确。网格越大，计算量越小，匹配越不精确。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135620-9f0bfc29-5273-4c53-b790-fbd987ed79da.png#align=left&display=inline&height=232&margin=%5Bobject%20Object%5D&originHeight=232&originWidth=454&size=0&status=done&style=none&width=454"><br>  NDT TKU作者在不同计算阶段定义不同网格大小。在初始匹配时，或者叫收敛阶段，对于机器人较近激光测量采用较小的网格，而距离机器人较远的，采用较大的网格。在初始匹配完成后，进行修正阶段时，对于远处的网格将同近处测量一样采用较小的网格。因为机器人朝向角的细微差异，会导致远处测量的巨大不确定性。因此，在初始搜索匹配时，对于远处的激光点云，采用较大的网格，对于近处的点云采用较小的网格。并且最终匹配计算，将近采用较小的网格。<br>下图为autoware NDT定位截图<br><img src="https://cdn.nlark.com/yuque/0/2020/png/2158811/1597132135622-454f024f-743b-4b38-94ea-5f301fb44f4b.png#align=left&display=inline&height=661&margin=%5Bobject%20Object%5D&originHeight=933&originWidth=1694&size=0&status=done&style=none&width=1200"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/07/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#NDT-Matching-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">NDT Matching 算法学习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="nav-number">2.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4ND"><span class="nav-number">3.</span> <span class="nav-text">二维ND</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2D-NDT%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">2D NDT数学描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%BD%91%E6%A0%BC%E5%B9%B6%E9%81%BF%E5%85%8D%E7%A6%BB%E6%95%A3%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">3.2.</span> <span class="nav-text">如何划分网格并避免离散化的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%89%87%E7%82%B9%E4%BA%91%E7%9B%B8%E5%AF%B9%E4%BD%8D%E5%A7%BF"><span class="nav-number">3.3.</span> <span class="nav-text">如何计算两片点云相对位姿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2D-NDT%E5%9C%A8SLAM%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text">2D NDT在SLAM中的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E7%BB%B4NDT"><span class="nav-number">4.</span> <span class="nav-text">三维NDT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%BB%B4NDT%E5%88%86%E5%B8%83%E6%95%B0%E5%AD%A6%E6%8F%8F%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">三维NDT分布数学描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3D-NDT%E5%88%86%E5%B8%83%E6%9B%B4%E6%96%B0"><span class="nav-number">4.2.</span> <span class="nav-text">3D NDT分布更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C3D%E7%82%B9%E4%BA%91NDT%E9%85%8D%E5%87%86"><span class="nav-number">4.3.</span> <span class="nav-text">如何进行3D点云NDT配准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NDT%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.4.</span> <span class="nav-text">NDT三维网格的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B"><span class="nav-number">4.5.</span> <span class="nav-text">如何改进</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
